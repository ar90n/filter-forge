// =============================================================
// AUTO-GENERATED by scripts/gen_bridge.py â€” DO NOT EDIT
// Source: src/python/filter_design.py
// Type: hooks
// Generated: 2026-02-14T01:53:32Z
// =============================================================

import { useState, useEffect, useCallback, useRef } from 'react'
import { wrap, type Remote } from 'comlink'
import type { FilterParams, FilterResult } from './filter_design.types'
import type { PyodideStatus, FilterDesignError } from '@/types/filter'

type WorkerApi = {
  initialize(): Promise<void>
  designFilter(params: unknown): Promise<unknown>
  getStatus(): PyodideStatus
}

// --- usePyodide: Worker lifecycle hook ---

export type UsePyodideReturn = {
  status: PyodideStatus
  error: string | null
  api: Remote<WorkerApi> | null
  retry: () => void
}

function createWorker(): { worker: Worker; api: Remote<WorkerApi> } {
  const worker = new Worker(
    new URL('./filter_design.worker.ts', import.meta.url),
    { type: 'module' },
  )
  const api = wrap<WorkerApi>(worker)
  return { worker, api }
}

/**
 * Wrapper to safely hold Comlink Proxy objects in React state.
 *
 * Problem: The Proxy returned by Comlink.wrap() has typeof === 'function'
 * due to internal traps, causing React's setState to invoke it as a
 * function updater -> "rawValue.apply is not a function" error.
 *
 * Solution: Wrap in a plain object { ref: proxy } so React never
 * directly operates on the Proxy.
 */
type ApiContainer = { ref: Remote<WorkerApi> } | null

export function usePyodide(): UsePyodideReturn {
  const [status, setStatus] = useState<PyodideStatus>('loading')
  const [error, setError] = useState<string | null>(null)
  const [apiContainer, setApiContainer] = useState<ApiContainer>(null)
  const workerRef = useRef<Worker | null>(null)
  const [retryCount, setRetryCount] = useState(0)

  useEffect(() => {
    let cancelled = false

    // Terminate existing Worker
    if (workerRef.current) {
      workerRef.current.terminate()
      workerRef.current = null
    }

    const { worker, api: wrappedApi } = createWorker()
    workerRef.current = worker

    wrappedApi.initialize().then(
      () => {
        if (!cancelled) {
          // Wrap in a plain object before passing to setState
          setApiContainer({ ref: wrappedApi })
          setStatus('ready')
          setError(null)
        }
      },
      (e: unknown) => {
        if (!cancelled) {
          setStatus('error')
          setError(e instanceof Error ? e.message : String(e))
          setApiContainer(null)
        }
      },
    )

    return () => {
      cancelled = true
      worker.terminate()
      workerRef.current = null
      setApiContainer(null)
    }
  }, [retryCount])

  const retry = useCallback(() => {
    setRetryCount((c) => c + 1)
  }, [])

  return {
    status,
    error,
    api: apiContainer?.ref ?? null,
    retry,
  }
}

// --- Per-function hooks ---

export type CalculationStatus = 'idle' | 'calculating' | 'done' | 'error'

export type UseFilterDesignReturn = {
  calculationStatus: CalculationStatus
  result: FilterResult | null
  error: FilterDesignError | null
  designFilter: (params: FilterParams) => Promise<void>
}

export function useFilterDesign(
  api: Remote<WorkerApi> | null,
  pyodideStatus: PyodideStatus,
): UseFilterDesignReturn {
  const [calculationStatus, setCalculationStatus] = useState<CalculationStatus>('idle')
  const [result, setResult] = useState<FilterResult | null>(null)
  const [error, setError] = useState<FilterDesignError | null>(null)

  const designFilter = useCallback(
    async (params: FilterParams) => {
      if (!api || pyodideStatus !== 'ready') {
        setError({
          code: 'PYODIDE_LOAD_ERROR',
          message: 'Calculation engine is not ready.',
        })
        setCalculationStatus('error')
        return
      }

      setCalculationStatus('calculating')
      setError(null)

      try {
        const rawResult = await api.designFilter(params)
        setResult(rawResult as FilterResult)
        setCalculationStatus('done')
      } catch (e) {
        const filterError: FilterDesignError =
          (e as FilterDesignError).code
            ? (e as FilterDesignError)
            : {
                code: 'CALCULATION_ERROR',
                message: e instanceof Error ? e.message : String(e),
              }
        setError(filterError)
        setResult(null)
        setCalculationStatus('error')
      }
    },
    [api, pyodideStatus],
  )

  return {
    calculationStatus,
    result,
    error,
    designFilter,
  }
}
