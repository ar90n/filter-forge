// =============================================================
// AUTO-GENERATED by scripts/gen_bridge.py â€” DO NOT EDIT
// Source: src/python/filter_design.py
// Type: worker
// Generated: 2026-02-14T02:36:03Z
// =============================================================

import { expose } from 'comlink'
import type { FilterParams, FilterResult } from './filter_design.types'
import type { FilterDesignError } from '@/types/filter'
import pythonScript from '@/python/filter_design.py?raw'

interface PyodideInterface {
  loadPackage(packages: string | string[]): Promise<void>
  runPython(code: string): unknown
  globals: {
    get(name: string): (...args: unknown[]) => unknown
  }
  toPy(obj: unknown): unknown
}

const PYODIDE_CDN = 'https://cdn.jsdelivr.net/pyodide/v0.26.4/full/'

let pyodide: PyodideInterface | null = null
let status: 'idle' | 'loading' | 'ready' | 'error' = 'idle'

async function loadPyodideFromCDN(): Promise<PyodideInterface> {
  const mod = await import(/* @vite-ignore */ `${PYODIDE_CDN}pyodide.mjs`)
  return await (mod.loadPyodide as (config: { indexURL: string }) => Promise<PyodideInterface>)({
    indexURL: PYODIDE_CDN,
  })
}

const api = {
  async initialize(): Promise<void> {
    if (status === 'ready') return
    status = 'loading'

    try {
      pyodide = await loadPyodideFromCDN()
      await pyodide.loadPackage(['scipy', 'sympy'])
      pyodide.runPython(pythonScript)
      status = 'ready'
    } catch (e) {
      status = 'error'
      throw e
    }
  },

  async designFilter(params: FilterParams): Promise<FilterResult> {
    if (!pyodide || status !== 'ready') {
      const err: FilterDesignError = {
        code: 'PYODIDE_LOAD_ERROR',
        message: 'Pyodide is not initialized yet.',
      }
      throw err
    }

    try {
      const fn = pyodide.globals.get('design_filter') as (
        params: unknown,
      ) => unknown

      const pyArg = pyodide.toPy(params)
      const pyResult = fn(pyArg) as {
        toJs(opts: { dict_converter: typeof Object.fromEntries }): Map<string, unknown> | Record<string, unknown>
        destroy(): void
      }

      const result = pyResult.toJs({ dict_converter: Object.fromEntries })
      pyResult.destroy()

      const jsResult = result instanceof Map ? Object.fromEntries(result) : result

      if (jsResult.error) {
        const error = jsResult.error as Record<string, unknown>
        const err: FilterDesignError = {
          code: (error.code as FilterDesignError['code']) || 'CALCULATION_ERROR',
          message: (error.message as string) || 'Unknown calculation error',
          details: error.details as string | undefined,
        }
        throw err
      }

      return deepConvertMaps(jsResult) as FilterResult
    } catch (e) {
      if ((e as FilterDesignError).code) {
        throw e
      }
      const err: FilterDesignError = {
        code: 'CALCULATION_ERROR',
        message: e instanceof Error ? e.message : String(e),
        details: e instanceof Error ? e.stack : undefined,
      }
      throw err
    }
  },


  getStatus(): 'idle' | 'loading' | 'ready' | 'error' {
    return status
  },
}

function deepConvertMaps(obj: unknown): unknown {
  if (obj instanceof Map) {
    const plain: Record<string, unknown> = {}
    for (const [key, value] of obj) {
      plain[String(key)] = deepConvertMaps(value)
    }
    return plain
  }
  if (Array.isArray(obj)) {
    return obj.map(deepConvertMaps)
  }
  if (
    obj !== null &&
    typeof obj === 'object' &&
    !(obj instanceof Float64Array) &&
    !(obj instanceof Int32Array)
  ) {
    const plain: Record<string, unknown> = {}
    for (const [key, value] of Object.entries(obj)) {
      plain[key] = deepConvertMaps(value)
    }
    return plain
  }
  return obj
}

expose(api)
